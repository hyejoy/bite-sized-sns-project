# middle ware

- 중간에 있는 도구로 해석
- 특정 로직에 순차적인 동작이 있을때 중간에 끼어 추가적인 작업을 진행하는 도구를 뜻함

## zustand middleward 종류

- 1. combine : Store의 타입을 자동 추론
- 2. immer : Store 내부의 상태 업데이트를 보다 편리하게 바꿈
- 3. subscribeWithSelectore: Store 내의 특정 값 변화시 이벤트 핸들러 호출
- 4. persist : Store를 로컬, 세션 스토리지에 보관
- 5. devtools : Store의 값을 개발자 도구에서 확인할 수 있음

### 이전 코드

```jsx
    export const useCounterStore = create<StoreType>(
        count: 0,
        actions: {
            increase: () => {
            set((store) => ({ count: store.count + 1 }));
            },
            decrease: () => {
            set((store) => ({ count: store.count - 1 }));
            },
        },
    );
```

### combine

- state와 action 함수들을 통으로 한꺼번에 객체에 넣는 방식이 아니라
  state끼리, action함수끼리 서로 분리해서 작성한다음에 결합시키는 방식으로 정의할 수 있도록 도와준다.
- 타입스크립트가 store의 타입을 더 정확히 추론할 수 있도록 만들어 줌
- 첫번째 인수를 기준으로 state 타입이 자동으로 추론되어 별도의 타입을 정의해주지 않아도 된다.
- **첫번째 인수**로는 스토어에 포함될 **state**
- **두번째 인수** 로는 콜백 함수로 매개변수 set, get을 받아와 **액션 함수들을 포함한 객체를 반환**

  ```jsx
  export const useCounterStore = create(
    combine(
      {
        count: 0,
        name: '이름',
        age: 11,
      },
      (set, get) => ({
        actions: {
          increase: () => {
            set((state) => ({ count: state.count + 1 }));
          },
          decrease: () => {
            set((state) => ({ count: state.count - 1 }));
          },
        },
      })
    )
  );

    // get함수에서 자동 추론됨
    (parameter) get: () => {
        count: number;
        name: string;
        age: number;
    }
  ```

### immer

- 액션함수의 상태 업데이트를 보다 편리하고 간단한 코드로 진행할 수 있도록 불변성 관리를 도와줌
- 업데이트 해야하는 구조가 중첩이 된다거나 복잡해지면 업데이트 코드가 복잡해지는데 이런 문제를 해결해줌
- **immer 설치 진행** : npm i immer
- 인수로 combine 함수의 호출 결과값을 전달하도록 하면됨

  ```jsx
  // 1️⃣ immer(combine) 형태
      export const useCounterStore = create(
      immer(
          combine(
          {
              count: 0,
              name: '최혜조',
              age: 30,
          },
          (set, get) => ({
              actions: {
              increase: () => {
                  set((state) => {
                  state.count += 1;
                  });
              },
              decrease: () => {
                  set((state) => {
                  state.count -= 1;
                  });
              },
              },
          })
          )
      )
      );

  // 2️⃣ immer 단독 사용
  export const useCounterStore = create<CounterStore>()(
  immer((set) => ({
      count: 0,
      increase: () => set((state) => { state.count += 1 }),
  }))
      );
  ```

### subscribeWithSelector

- 셀렉터 함수를 통해서 스토어의 특정 값을 구독함으로써 해당 값이 변경될 때마다
  어떠한 기능을 추가로 수행하도록 만들어주는 react의 useEffect같은 기능을 수행하는 미들웨어
- immer의 호출을 전부 감싸도록 실습 진행함
- subscribe 함수를 호출하여 셀렉터 함수를 이용하여 특정값 구독
  - 셀렉터 함수 : sotre부터 특정 값만 따로 별도로 선택해서 불러오도록 사용했던 callback 함수
- subscribe 첫번째 매개변수로는 셀렉터함수를 이용해 특정 값 구독,
- 두번째 매개변수로는 해당 값이 변경될때 실행되는 callback 함수 작성
  - update된 값, 이전 값 매개변수로 받아올 수 있음
- ❕ 주로, 사용자가 로그아웃을 해서 세션을 보관하는 어떤 스토어의 값이 바뀌었을 때 로그인 페이지로 보낸다거나 하는
  사이드 이펙트를 관리할 때 종종 사용함

  ```jsx
  export const useCount = () => {
    const count = useCounterStore((state) => state.count);
    //                             ∟ 이부분이 셀렉터 함수
  };

  export const useCountStore = create(
    subscribeWithSelector(
      immer(
        combine(
          {
            count: 0,
          },
          (set, get) => ({
            actions: {
              increaseOne: () => {
                set((state) => {
                  state.count += 1;
                });
              },
            },
          })
        )
      )
    )
  );
  ```

```tsx
/**
 *  매개변수 store를 받아와 count값 구독
 *  첫번째 매개변수로는 셀렉터 함수로 특정값 구독,
 *  두번째 인수로는 변경될때 실행될 callback 함수 (리스너 함수)
 *  store의 다른 값을 불러올 수 있음 (getState 함수 사용)
 *  store의 다른 값을 변경할 수 있음 (setState 함수 사용)
 */
useCountStore.subscribe(
  (store) => store.count,
  (count, prevCount) => {
    console.log(count); // 업데이트 값
    console.log(prevCount); // 이전 값

    const store = useCountStore.getState(); // store의 다른값을 변경하고 싶은 경우 sotre의 값 반환하는 함수
    useCountStore.setState((store) => {
      // setState 함수를 이용하여 반환된 store의 값을 직접 변경
      name: '변경할 이름';
    });
  }
);
```

### persist

- 현재 스토어의 값을 브라우저의 스토리지, 로컬 스토리지나 세션 스토리지에 보관하도록 해주는 미들웨어
- persist를 이용하면 스토어의 값을 로컬 스토리지에 보관해두면 리엑트 앱이 초기화 되었을때 스토리지의 값을
  그대로 불러와 적용시켜줌
- 첫번째 인수로는, create안에 작성했던 store내용
- 두번째 인수로는, 특정 객체 설정
- 참고로 스토리지에 actions는 저장되지않음 (함수는 JSON형태로 파싱이 어렵기때문임)
  이렇게 되면, actions는 {} 로 저장되고, 앱이 초기화되면 액션함수 실행이 안됨
- 따라서 **pertialize 옵션**을 이용해, 셀렉터 함수를 이용해서 현재 스토어의 값들 중 어떤 것들을 스토리지에
  보관할건지 직접 명시하는것이 안전함
- **sotrage 옵션**을 사용하면 세션 스토리지에 데이터를 보관할수 있게 설정할 수 있다.
  - createJSONStorage 함수를 호출한다음에 콜백 함수로 session Storage를 반환하도록 하면됨

```tsx
const useCounterStore = create(
  persist(
    // 첫번째 인수
    combine({ counter: 0, name: 'name' }, (set, get) => ({
      actions: {
        increaseOne: () => {
          set((state) => state.count + 1);
        },
      },
    })),
    // 두번째 인수 : 특정 객체 설정
    {
      name: 'counterStore', // 스토리지 보관될때 쓰는 이름 설정
      pertialize: (store) => ({
        count: store.count, // 액션 함수를 제외한 count값만 스토리지에 보관
      }),
      storage: createJSONStorage(() => sessionStorage), //로컬 스토리지 대신 세션 스토리지의 데이터 보관
    }
  )
);
```

### devtools

- 개발자 도구를 통해 store를 디버깅할 수 있도록 도와주는 미들웨어
- 첫번째 인수로는, 함수 호출내용을 최상위에 전부 감싸도록 설정
- 두번째 인수로는 객체 형태의 옵션 전달
  - name: "현재 스토어의 이름을 넣어주세요."
- chrome 확장 프로그램 설치 해야함 **Redux DevTools**
  - 개발자도구의 Redux tab 클릭

```tsx
const useCounterStore = create(
  devtools(
    persist(
      // 첫번째 인수
      combine({ counter: 0, name: 'name' }, (set, get) => ({
        actions: {
          increaseOne: () => {
            set((state) => state.count + 1);
          },
        },
      })),
      // 두번째 인수 : 특정 객체 설정
      {
        name: 'counterStore', // 스토리지 보관될때 쓰는 이름 설정
        pertialize: (store) => ({
          count: store.count, // 액션 함수를 제외한 count값만 스토리지에 보관
        }),
        storage: createJSONStorage(() => sessionStorage), //로컬 스토리지 대신 세션 스토리지의 데이터 보관
      }
    ),
    {
      name: 'countStore', // 현재 스토어 이름
    }
  )
);
```

### middleware 적용순서

- 적용순서 중요함
- combine , immer, subscribeWithSelector, persist, devtools 순으로 적용하는것을 추천

# 7. [TanStack Query] 데이터 정규화(Normalization) 완벽 가이드

데이터 정규화란 **전체 리스트 캐시**에서 객체를 직접 들고 있는 대신, **객체는 각각의 상세 캐시(Detail)**에 넘겨주고 **리스트 캐시에는 ID 배열**만 남기는 최적화 기법입니다.

---

## 1. 왜 정규화가 필요한가요? (핵심 이유)

1. **데이터 중복 제거**: 리스트 데이터 안에도 '할 일 A'가 있고, 상세 데이터 안에도 '할 일 A'가 있으면 메모리가 낭비됩니다.
2. **데이터 일관성 보장**: 리스트에서 '할 일 A'를 수정했을 때, 상세 페이지의 데이터도 자동으로 바뀌게 하려면 데이터 저장소가 한 곳(Detail 캐시)이어야 합니다.
3. **UX 향상**: 리스트를 불러오는 순간 모든 상세 데이터가 캐싱되므로, 상세 페이지 이동 시 로딩 창 없이 즉시 데이터가 보입니다.

---

## 2. 정규화 구현 로직 (흐름도)

### Step 1: 리스트 호출 시 데이터를 쪼개서 저장하기

`useTodosData`는 서버에서 받아온 뭉텅이 데이터를 각자의 방(`detail`)으로 흩뿌려줍니다.

```tsx
/** hooks/queries/useTodosData.ts */
export function useTodosData() {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: QUERY_KEYS.todo.list,
    queryFn: async () => {
      const todos = await fetchTodos(); // 서버에서 [{}, {}, {}] 형태의 배열을 받음

      // 1. [뿌리기] 각 todo 객체를 자신의 ID를 키로 하는 '상세 캐시'에 하나씩 심어줌
      todos.forEach((todo) => {
        queryClient.setQueryData<Todo>(QUERY_KEYS.todo.detail(todo.id), todo);
      });

      // 2. [남기기] 리스트 캐시에는 객체 대신 ID만 모은 배열 ["1", "2", "3"]을 반환함
      return todos.map((todo) => todo.id);
    },
  });
}
```

### Step 2: 필요한 데이터만 쏙쏙 골라 쓰기

- 이제 TodoListPage는 ID 배열만 받습니다. 실제 데이터는 자식 컴포넌트인 TodoItem이 자신의 ID를 가지고 캐시에서 직접 찾아옵니다.

```tsx
/** components/TodoItem.tsx */
export default function TodoItem({ id }: { id: string }) {
  // 이미 useTodosData에서 심어둔 캐시 데이터가 있으므로 네트워크 요청 없이 바로 todo를 가져옴
  // 'LIST' 타입을 넘겨 리스트 화면에서는 불필요한 리패칭을 막음
  const { data: todo } = useTodoDataById(id, 'LIST');

  if (!todo) return null;
  const { content, isDone } = todo; // 이제야 실제 내용을 사용함
  // ... 생략
}
```

## 3. 정규화 이후의 Mutation 처리 (C.U.D)

- 데이터가 정규화되면 값을 수정하거나 삭제할 때 전체 리스트가 아닌 해당 ID의 상세 캐시를 건드려야 합니다.

- ① 수정 (Update): 특정 방의 데이터만 교체
  리스트를 건드릴 필요 없이, 해당 ID의 detail 캐시만 수정하면 TodoItem이 알아서 바뀝니다.

```tsx
/** hooks/mutations/useUpdateTodoMutation.ts */
onMutate: async (updateTodo) => {
  // 해당 ID의 상세 캐시 데이터만 업데이트
  queryClient.setQueryData(QUERY_KEYS.todo.detail(updateTodo.id), (prev) => ({
    ...prev,
    ...updateTodo,
  }));
};
```

- ② 삭제 (Delete): 방을 없애고 리스트에서 이름 지우기
  상세 캐시를 제거하고, 리스트 캐시(ID 배열)에서 해당 ID를 필터링합니다.

```tsx
/** hooks/mutations/useDeleteTodoMutation.ts */
onSuccess: (_, deletedId) => {
  // 1. 상세 캐시 방 폭파
  queryClient.removeQueries({ queryKey: QUERY_KEYS.todo.detail(deletedId) });
  // 2. 리스트(ID 배열)에서 해당 ID 삭제
  queryClient.setQueryData<string[]>(QUERY_KEYS.todo.list, (prev) =>
    prev?.filter((id) => id !== deletedId)
  );
};
```

- ③ 생성 (Create): 새 방을 만들고 리스트에 이름 추가
  새 객체는 detail 캐시에 넣고, 그 ID는 list 캐시(배열) 맨 뒤에 붙여줍니다.

```tsx
/** hooks/mutations/useCreateTodoMutation.ts */
onSuccess: (newTodo) => {
  // 1. 새 상세 캐시 방 생성
  queryClient.setQueryData(QUERY_KEYS.todo.detail(newTodo.id), newTodo);
  // 2. 리스트(ID 배열) 끝에 새 ID 추가
  queryClient.setQueryData<string[]>(QUERY_KEYS.todo.list, (prev) =>
    prev ? [...prev, newTodo.id] : [newTodo.id]
  );
};
```

### 최종 요약: 이 방식의 핵심

- 데이터 주인은 누구?: todo.detail(id) 캐시입니다.

- 리스트 캐시의 역할은?: 어떤 ID들이 어떤 순서로 보여질지만 결정하는 '목차' 역할입니다.

- 장점: 어떤 페이지(리스트/상세)에서 데이터를 수정하든 모든 화면이 동기화되며, 앱이 비약적으로 빨라집니다.

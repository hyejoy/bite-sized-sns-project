# 리패칭 해야하는 데이터가 너무 많을 때 [CreateTodo 함수의 반환 값을 사용]

- 이전에 학습했던 mutation의 onSuccess 핸들러에 queryClient의 invalidateQueries 메서드를 활용해서
  queryKey Factory까지 적용해 todoList 캐시 데이터를 무효화 시키는 방식으로,
  todo 아이템 추가 이후에 데이터를 수정한 뒤에 변경된 데이터를 다시 불러오도록 하는 방식이였음

- 그런데 이런 방식은 직관적이고 간단하지만, BE서버에 가져오는 TODO 아이템의 갯수가 많아질수록
  리패칭해야하는 데이터의 양이 계속해서 증가할거기 때문에, 자칫 서버에 부하를 일으킬 가능성이 있음

- 리패칭 양이 많아질 것 같은 경우에는 캐시 데이터를 무효화 하는것보다 CreateTodo함수의 반환값을 이용하는
  새로운 방식을 사용하면 됨

- fetch 함수의 반환값인 data는 mutation의 onSuccess 매개변수로 반환되는 점을 이용

```ts
/** createTodo.ts */
import { API_URL } from '@/lib/constants';
import type { Todo } from '@/types';

export async function createTodo(content: string) {
  const res = await fetch(`${API_URL}/todos`, {
    method: 'post',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      content,
      isDone: false,
    }),
  });

  if (!res.ok) throw new Error('create todo failed');
  const data: Todo = await res.json();
  return data; // 이값이 mutation onSuccess 이벤트 핸들러의 매개변수로 제공됨
}
```

- 매개변수로 제공된 새로운 todoItem을 쿼리키값을 갖는 캐시데이터에 직접 추가해주면 되는것임
- 그렇게 되면 굳이 invalidateQueries 메서드를 호출할 필요가 없어짐

## setQueryData 사용

```tsx
import { createTodo } from '@/api/createTodo';
import { QUERY_KEYS } from '@/lib/constants';
import type { Todo } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';

export function useCreateTodoMutation() {
  // 1. queryClient 불러오기
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: createTodo,
    onMutate: () => {},
    onSettled: () => {},
    onSuccess: (newTodo) => {
      // setQueryData함수 이용 → Todo[] 형태의 데이터 수정함을 명시
      // 첫번째 인수로는 수정할 캐시 데이터의 키값
      // 두번째 인수로는 setState를 사용하는 것처럼 화살표 함수 넘겨주기
      queryClient.setQueryData<Todo[]>(QUERY_KEYS.todo.list, (prevTodos) => {
        if (!prevTodos) return [newTodo];
        return [...prevTodos, newTodo];
      });
    },
    onError: (error) => {
      window.alert(error.message);
    },
  });
}
```

# 6. [TanStack Query] 데이터 삭제 및 UI 동기화 (DELETE)

데이터를 삭제할 때 단순히 서버에 요청만 보내는 것이 아니라, 사용자 경험을 위해 로딩 상태를 처리하고 삭제 성공 시 화면에서 즉시 제거하는 방법을 정리합니다.

## 1. 구현 단계 및 코드 분석

### ① 삭제 API 함수 (`api/deleteTodo.ts`)

- `fetch`를 사용해 서버에 `DELETE` 메서드 요청을 보냅니다.
- `json-server`와 같은 환경에서는 삭제된 아이템의 데이터를 응답으로 보내주므로 이를 반환하여 활용할 수 있습니다.

```tsx
import { API_URL } from '@/lib/constants';
import type { Todo } from '@/types';

export async function deleteTodo(id: string) {
  const response = await fetch(`${API_URL}/todos/${id}`, {
    method: 'DELETE',
  });

  if (!response.ok) throw new Error('delete todo failed');
  const data: Todo = await response.json(); // 삭제된 todo item 반환
  return data;
}
```

### ② 삭제 커스텀 훅 (hooks/mutations/useDeleteTodoMutation.ts)

- useMutation의 onSuccess 옵션을 사용하여 서버 요청이 성공한 시점에 캐시 데이터를 수동으로 수정합니다.ㄴ
- queryClient.setQueryData를 통해 기존 리스트에서 삭제된 ID를 제외한 데이터만 남도록 필터링하여 즉각적인 UI 변화를 유도합니다.

```tsx
import { deleteTodo } from '@/api/deleteTodo';
import { QUERY_KEYS } from '@/lib/constants';
import type { Todo } from '@/types';
import { useMutation, useQueryClient } from '@tanstack/react-query';

export function useDeleteTodoMutation() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: deleteTodo,
    // onSuccess의 두 번째 인자인 deletedId(mutate 호출 시 전달한 값)를 활용
    onSuccess: (_, deletedId) => {
      queryClient.setQueryData<Todo[]>(QUERY_KEYS.todo.list, (prevTodos) => {
        if (!prevTodos) return [];
        // 현재 캐시된 리스트에서 삭제된 ID만 제외하고 다시 저장
        return prevTodos.filter((todo) => todo.id !== deletedId);
      });
    },
  });
}
```

### ③ 컴포넌트 적용 및 UX 최적화 (components/TodoItem.tsx)

- 삭제 버튼 클릭 시 deleteTodo(id)를 호출합니다.
- Pending 상태 처리: 삭제가 진행 중일 때(isPending) 버튼과 체크박스를 비활성화하여 중복 요청이나 삭제 중 수정을 방지합니다.

```tsx
import { Button } from '@/components/ui/button';
import { useDeleteTodoMutation } from '@/hooks/mutations/useDeleteTodoMutation';
import type { Todo } from '@/types';

export default function TodoItem({ id, content, isDone }: Todo) {
  const { mutate: deleteTodo, isPending: isDeleteTodoPending } =
    useDeleteTodoMutation();

  const handleDeleteClick = () => {
    deleteTodo(id);
  };

  return (
    <div className="flex items-center justify-between border p-2">
      <div className="flex gap-5">
        <input
          disabled={isDeleteTodoPending} // 삭제 중 클릭 방지
          type="checkbox"
          checked={isDone}
        />
        <span>{content}</span>
      </div>
      <Button
        variant={'destructive'}
        disabled={isDeleteTodoPending} // 삭제 중 버튼 비활성화
        onClick={handleDeleteClick}
      >
        삭제
      </Button>
    </div>
  );
}
```

## 2. 주요 핵심 요약

- 서버 응답 활용: onSuccess에서 서버에서 삭제된 ID를 참조하여 로컬 캐시를 직접 수정함으로써 불필요한 전체 리스트 재요청(GET)을 줄일 수 있습니다.

- isPending 활용: 비동기 작업이 진행 중임을 disabled 속성으로 시각화하여 사용자가 작업 상태를 인지하게 하고 오작동을 막습니다.

- 사용자 경험(UX): TanStack Query는 최대한 로딩 화면을 줄이는 방식으로 최적화를 도와주며, 수동 캐시 업데이트는 이를 극대화하는 방법입니다.

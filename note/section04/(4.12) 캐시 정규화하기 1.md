# 7. [TanStack Query] 데이터 정규화(Normalization)를 통한 캐시 최적화

데이터 정규화는 전체 리스트 데이터(`todo.list`)와 개별 상세 데이터(`todo.detail`) 사이의 중복을 제거하고, 캐시의 데이터 일관성을 유지하기 위해 수행하는 최적화 작업입니다.

## 1. 정규화가 필요한 이유 (Before)

- **중복 발생**: `todo.list`를 불러올 때 이미 모든 투두의 상세 정보가 포함되어 있음에도 불구하고, 상세 페이지에 진입할 때 `todo.detail(id)` 키로 데이터를 또다시 요청하거나 별도로 저장해야 함.
- **데이터 불일치**: 전체 리스트에서 특정 투두를 수정했을 때, 상세 페이지의 캐시 데이터는 업데이트되지 않아 서로 다른 정보를 보여주는 문제가 발생할 수 있음.

---

## 2. 정규화 적용 과정 (After)

정규화 후에는 `todo.list` 캐시에 전체 객체를 저장하는 대신 **ID 배열만 저장**하고, 실제 객체 데이터는 각자의 **상세 키(`detail`)에 분산 저장**합니다.

### ① 데이터 정규화 적용 (hooks/queries/useTodosData.ts)

`queryFn` 내부에서 비동기 데이터를 가져온 후, `forEach`를 돌며 각 아이템을 개별 상세 캐시에 직접 심어주는 과정이 핵심입니다.

```tsx
import { fetchTodos } from '@/api/fetchTodos';
import { QUERY_KEYS } from '@/lib/constants';
import { Todo } from '@/types';
import { useQuery, useQueryClient } from '@tanstack/react-query';

export function useTodosData() {
  const queryClient = useQueryClient();

  return useQuery({
    queryKey: QUERY_KEYS.todo.list,
    queryFn: async () => {
      // 1. 서버에서 전체 투두 리스트 객체를 가져옴
      const todos = await fetchTodos();

      // 2. [정규화 핵심] 가져온 객체들을 순회하며 개별 상세 캐시(Detail)에 미리 저장
      // 이렇게 하면 상세 페이지 진입 시 별도의 네트워크 요청 없이 캐시된 데이터를 바로 사용 가능함
      todos.forEach((todo) => {
        queryClient.setQueryData<Todo>(QUERY_KEYS.todo.detail(todo.id), todo);
      });

      // 3. [반환값 변경] 캐시(todo.list)에는 객체 전체가 아닌 ID 값만 담긴 배열을 반환하여 저장
      // 결과적으로 QUERY_KEYS.todo.list는 string[] 타입을 가지게 됨
      return todos.map((todo) => todo.id);
    },
  });
}
```

### ② 상세 데이터 사용 (hooks/queries/useTodoDataById.ts)

-이미 useTodosData에서 데이터를 심어두었기 때문에, 상세 데이터를 조회할 때 매우 효율적으로 동작합니다.

```tsx
export function useTodoDataById(id: string) {
  return useQuery({
    queryKey: QUERY_KEYS.todo.detail(id),
    // 만약 리스트를 먼저 불러왔다면, queryFn이 실행되기도 전에
    // 이미 캐시에 저장된 데이터를 찾아 즉시 화면에 보여줌 (Stale-while-revalidate)
    queryFn: () => fetchTodoById(id),
    // 리스트에서 이미 상세 데이터를 넣어줬으므로,
    // 초기 로딩 없이 부드러운 전환이 가능함
  });
}
```

## 3. 정규화의 장점 요약

- 데이터 일관성: 특정 ID의 투두를 수정하면 해당 ID의 detail 캐시만 업데이트하면 되므로, 이를 참조하는 모든 곳에서 동일한 최신 데이터를 보게 됨.

- 불필요한 요청 감소: 전체 리스트를 한 번만 불러오면 모든 개별 상세 데이터가 자동으로 캐싱되므로 추가적인 API 호출이 줄어듬.

- 메모리 효율: 중복된 객체 데이터를 여러 곳에 저장하지 않고 ID 배열로 관리하여 메모리 낭비를 방지함.

- 빠른 UX: 상세 페이지로 이동할 때 로딩 스피너를 거치지 않고 캐시된 데이터를 즉시 보여줄 수 있음.

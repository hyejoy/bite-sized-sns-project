# Zustand란

- 리엑트의 내장기능인 Context API를 비롯한 전역 상태 관리를 위한 라이브러리
- Context API는 전역상태의 기능이라고 보기보다는 props drilling이슈를 해결하기 위해 제공되는 기능이라고 봐야하는데, Context Provider의 상태값이 변하면 그 밑의 하위 컴포넌트도 불필요하게 리랜더링 되는 한계점이 존재
- 그렇기때문에 Context API는 특정 컴포넌트들끼리만 공유하는 데이터를 다룰때 더 효과적으로 사용함 (국소적인 관리)
- 완전한 전역 상태 관리를 위해서는 Redux나 Zustand와 같은 전역 상태 관리를 위해 만들어진 라이브러리를 활용

## Zustand를 쓰는 이유

- 많은 사람들이 사용하고 있음
- 용량이 매우 가벼움 (KB)
- 매우 직관적이여서 배우기 쉬움
  - 별도의 설정파일 없이 create 함수로 바로 사용 가능

## Zustand 기본 사용법

### npm i zustand

### create 함수로 이용하여 store 생성하기

- 전역 상태인 state와 해당 상태를 실제로 업데이트 하는 액션 함수들이 포함된 객체
- 즉 state, action 함수를 포함하는 객체인 store를 생성하는 것

  ```jsx
  import { create } from 'zustand';

  const useCountStore = create((set, get) => ({
    count: 0, // state 생성
    increase: () => set((state) => state + 1),
    decrease: () => set((state) => state - 1),
  }));
  ```

  - create 함수의 매개변수로 전달되는 set, get 함수를 이용하여 state값을 꺼내오고 설정할 수 있음
  - set 메서드는 함수형 업데이트도 지원함
  - set 메서드는 매개변수로 현재 store의 값이 제공됨
  - create함수 뒤에 제네릭으로 타입 명시해 주기

  ```jsx
  import { create } from 'zustand';

  type CounterStore = {
  count: number;
  increase: () => void;
  decrease: () => void;
  };


  export const useCounterStore = create<CounterStore>((set) => ({
    count: 0,
    increase: () => {
      set((store) => ({ count: store.count + 1 }));
    },
    decrease: () => {
      set((store) => ({ count: store.count - 1 }));
    },
  }));
  ```

### store 사용하기

    - create함수는 생성한 스토어에 접근할 수 있도록 react hook을 반환함

    ```jsx
    import { Button } from '@/components/ui/button';
    import { useCounterStore } from '@/store/count';

    export default function CounterPage() {
    const { count, increase, decrease } = useCounterStore(); // ⭐
    return (
        <>
            <h1 className="text-2xl font-bold">CounterPage Component</h1>
            <div>{count}</div>
            <div>
                <Button onClick={decrease}>-</Button>
                <Button onClick={increase}>+</Button>
            </div>
        </>
    );
    }

    ```

### 불필요한 랜더링 막기

- Zustand는 컴포넌트에서 불러온 스토어의 값들 중에 하나라도 업데이트하면 해당 컴포넌트를 자동으로 리렌더링 시킴
- store객체의 전부를 불러오게 되면 (전체 스토어의 객체가 반환됨) 불필요한 랜더링 발생됨

  ```jsx
  /** Store 객체의 전부를 불러오는 예시 코드 */
  const { increase, decrease } = useCounterStore();
  ```

- store에서 셀렉터 함수(스토어로부터 어떤 값을 꺼내올 건지 명시하는 함수) 전달하면 됨

  ```jsx
  /** 셀렉터 함수 사용 예시 코드 */
  const increase = useCounterStore((state) => state.increase);
  const decrease = useCounterStore((state) => state.decrease);
  ```

- 두줄로 쓰기 귀찮다면 actions로 묶기

  ```jsx
  /** CounterStore.ts */
  import { create } from 'zustand';

    type CounterStore = {
      actions: {
        increase: () => void;
        decrease: () => void;
      };
    };
    ...
      actions: {
        increase: () => {
          set((store) => ({ count: store.count + 1 }));
        },
        decrease: () => {
          set((store) => ({ count: store.count - 1 }));
        },
      },



    /** Controller.tsx */
    ...
    const { increase, decrease } = useCounterStore((store) => store.actions);

  ```

### custom hook 만들어 사용하기

- 셀렉터 함수를 사용하게 되면, 스토어의 키값이 변경될때 다 바꿔줘야해서 유지보수가 어려움
- store 페이지만 수정할 수 있게, customhook을 만들어 사용하는것이 일반적이다.

  ```jsx
  /** counterStore.ts _ custom hook */
  export const useCount = () => {
    const count = useCounterStore((state) => state.count);
    return count;
  };

  export const useIncreaseCount = () => {
    return useCounterStore((state) => state.actions.increase);
  };

  export const useDecreaseCount = () => {
    return useCounterStore((state) => state.actions.decrease);
  };

  /**component */
  const increase = useIncreaseCount();
  const decrease = useDecreaseCount();
  ```
